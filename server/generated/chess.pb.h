// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chess.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_chess_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_chess_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chess_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_chess_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_chess_2eproto;
namespace chess {
namespace standard {
class BoardState;
struct BoardStateDefaultTypeInternal;
extern BoardStateDefaultTypeInternal _BoardState_default_instance_;
class GameOverMessage;
struct GameOverMessageDefaultTypeInternal;
extern GameOverMessageDefaultTypeInternal _GameOverMessage_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Move;
struct MoveDefaultTypeInternal;
extern MoveDefaultTypeInternal _Move_default_instance_;
class MoveMessage;
struct MoveMessageDefaultTypeInternal;
extern MoveMessageDefaultTypeInternal _MoveMessage_default_instance_;
class MoveResultMessage;
struct MoveResultMessageDefaultTypeInternal;
extern MoveResultMessageDefaultTypeInternal _MoveResultMessage_default_instance_;
class Piece;
struct PieceDefaultTypeInternal;
extern PieceDefaultTypeInternal _Piece_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
}  // namespace standard
}  // namespace chess
PROTOBUF_NAMESPACE_OPEN
template<> ::chess::standard::BoardState* Arena::CreateMaybeMessage<::chess::standard::BoardState>(Arena*);
template<> ::chess::standard::GameOverMessage* Arena::CreateMaybeMessage<::chess::standard::GameOverMessage>(Arena*);
template<> ::chess::standard::Message* Arena::CreateMaybeMessage<::chess::standard::Message>(Arena*);
template<> ::chess::standard::Move* Arena::CreateMaybeMessage<::chess::standard::Move>(Arena*);
template<> ::chess::standard::MoveMessage* Arena::CreateMaybeMessage<::chess::standard::MoveMessage>(Arena*);
template<> ::chess::standard::MoveResultMessage* Arena::CreateMaybeMessage<::chess::standard::MoveResultMessage>(Arena*);
template<> ::chess::standard::Piece* Arena::CreateMaybeMessage<::chess::standard::Piece>(Arena*);
template<> ::chess::standard::Position* Arena::CreateMaybeMessage<::chess::standard::Position>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace chess {
namespace standard {

enum PieceType : int {
  PAWN = 0,
  ROOK = 1,
  KNIGHT = 2,
  BISHOP = 3,
  QUEEN = 4,
  KING = 5,
  PieceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PieceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PieceType_IsValid(int value);
constexpr PieceType PieceType_MIN = PAWN;
constexpr PieceType PieceType_MAX = KING;
constexpr int PieceType_ARRAYSIZE = PieceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PieceType_descriptor();
template<typename T>
inline const std::string& PieceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PieceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PieceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PieceType_descriptor(), enum_t_value);
}
inline bool PieceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PieceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PieceType>(
    PieceType_descriptor(), name, value);
}
enum PieceColor : int {
  WHITE = 0,
  BLACK = 1,
  PieceColor_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PieceColor_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PieceColor_IsValid(int value);
constexpr PieceColor PieceColor_MIN = WHITE;
constexpr PieceColor PieceColor_MAX = BLACK;
constexpr int PieceColor_ARRAYSIZE = PieceColor_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PieceColor_descriptor();
template<typename T>
inline const std::string& PieceColor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PieceColor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PieceColor_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PieceColor_descriptor(), enum_t_value);
}
inline bool PieceColor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PieceColor* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PieceColor>(
    PieceColor_descriptor(), name, value);
}
enum MessageType : int {
  MOVE = 0,
  MOVE_RESULT = 1,
  GAME_OVER = 2,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = MOVE;
constexpr MessageType MessageType_MAX = GAME_OVER;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum GameEndReason : int {
  CHECKMATE = 0,
  STALEMATE = 1,
  RESIGNATION = 2,
  AGREED_DRAW = 3,
  TIME_OUT = 4,
  GameEndReason_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GameEndReason_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GameEndReason_IsValid(int value);
constexpr GameEndReason GameEndReason_MIN = CHECKMATE;
constexpr GameEndReason GameEndReason_MAX = TIME_OUT;
constexpr int GameEndReason_ARRAYSIZE = GameEndReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameEndReason_descriptor();
template<typename T>
inline const std::string& GameEndReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GameEndReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GameEndReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GameEndReason_descriptor(), enum_t_value);
}
inline bool GameEndReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GameEndReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameEndReason>(
    GameEndReason_descriptor(), name, value);
}
// ===================================================================

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chess.standard.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  explicit PROTOBUF_CONSTEXPR Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Position& from) {
    Position::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chess.standard.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chess.standard.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chess_2eproto;
};
// -------------------------------------------------------------------

class Piece final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chess.standard.Piece) */ {
 public:
  inline Piece() : Piece(nullptr) {}
  ~Piece() override;
  explicit PROTOBUF_CONSTEXPR Piece(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Piece(const Piece& from);
  Piece(Piece&& from) noexcept
    : Piece() {
    *this = ::std::move(from);
  }

  inline Piece& operator=(const Piece& from) {
    CopyFrom(from);
    return *this;
  }
  inline Piece& operator=(Piece&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Piece& default_instance() {
    return *internal_default_instance();
  }
  static inline const Piece* internal_default_instance() {
    return reinterpret_cast<const Piece*>(
               &_Piece_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Piece& a, Piece& b) {
    a.Swap(&b);
  }
  inline void Swap(Piece* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Piece* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Piece* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Piece>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Piece& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Piece& from) {
    Piece::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Piece* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chess.standard.Piece";
  }
  protected:
  explicit Piece(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 4,
    kIdFieldNumber = 1,
    kPieceTypeFieldNumber = 2,
    kColorFieldNumber = 3,
  };
  // .chess.standard.Position position = 4;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::chess::standard::Position& position() const;
  PROTOBUF_NODISCARD ::chess::standard::Position* release_position();
  ::chess::standard::Position* mutable_position();
  void set_allocated_position(::chess::standard::Position* position);
  private:
  const ::chess::standard::Position& _internal_position() const;
  ::chess::standard::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::chess::standard::Position* position);
  ::chess::standard::Position* unsafe_arena_release_position();

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // .chess.standard.PieceType piece_type = 2;
  void clear_piece_type();
  ::chess::standard::PieceType piece_type() const;
  void set_piece_type(::chess::standard::PieceType value);
  private:
  ::chess::standard::PieceType _internal_piece_type() const;
  void _internal_set_piece_type(::chess::standard::PieceType value);
  public:

  // .chess.standard.PieceColor color = 3;
  void clear_color();
  ::chess::standard::PieceColor color() const;
  void set_color(::chess::standard::PieceColor value);
  private:
  ::chess::standard::PieceColor _internal_color() const;
  void _internal_set_color(::chess::standard::PieceColor value);
  public:

  // @@protoc_insertion_point(class_scope:chess.standard.Piece)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::chess::standard::Position* position_;
    int32_t id_;
    int piece_type_;
    int color_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chess_2eproto;
};
// -------------------------------------------------------------------

class BoardState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chess.standard.BoardState) */ {
 public:
  inline BoardState() : BoardState(nullptr) {}
  ~BoardState() override;
  explicit PROTOBUF_CONSTEXPR BoardState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoardState(const BoardState& from);
  BoardState(BoardState&& from) noexcept
    : BoardState() {
    *this = ::std::move(from);
  }

  inline BoardState& operator=(const BoardState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoardState& operator=(BoardState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoardState& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoardState* internal_default_instance() {
    return reinterpret_cast<const BoardState*>(
               &_BoardState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BoardState& a, BoardState& b) {
    a.Swap(&b);
  }
  inline void Swap(BoardState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoardState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoardState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoardState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoardState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoardState& from) {
    BoardState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoardState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chess.standard.BoardState";
  }
  protected:
  explicit BoardState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPiecesFieldNumber = 1,
  };
  // repeated .chess.standard.Piece pieces = 1;
  int pieces_size() const;
  private:
  int _internal_pieces_size() const;
  public:
  void clear_pieces();
  ::chess::standard::Piece* mutable_pieces(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chess::standard::Piece >*
      mutable_pieces();
  private:
  const ::chess::standard::Piece& _internal_pieces(int index) const;
  ::chess::standard::Piece* _internal_add_pieces();
  public:
  const ::chess::standard::Piece& pieces(int index) const;
  ::chess::standard::Piece* add_pieces();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chess::standard::Piece >&
      pieces() const;

  // @@protoc_insertion_point(class_scope:chess.standard.BoardState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chess::standard::Piece > pieces_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chess_2eproto;
};
// -------------------------------------------------------------------

class Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chess.standard.Move) */ {
 public:
  inline Move() : Move(nullptr) {}
  ~Move() override;
  explicit PROTOBUF_CONSTEXPR Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Move(const Move& from);
  Move(Move&& from) noexcept
    : Move() {
    *this = ::std::move(from);
  }

  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline Move& operator=(Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const Move* internal_default_instance() {
    return reinterpret_cast<const Move*>(
               &_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Move& a, Move& b) {
    a.Swap(&b);
  }
  inline void Swap(Move* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Move* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Move>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Move& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Move& from) {
    Move::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Move* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chess.standard.Move";
  }
  protected:
  explicit Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromPositionFieldNumber = 2,
    kToPositionFieldNumber = 3,
    kPieceIdFieldNumber = 1,
  };
  // .chess.standard.Position from_position = 2;
  bool has_from_position() const;
  private:
  bool _internal_has_from_position() const;
  public:
  void clear_from_position();
  const ::chess::standard::Position& from_position() const;
  PROTOBUF_NODISCARD ::chess::standard::Position* release_from_position();
  ::chess::standard::Position* mutable_from_position();
  void set_allocated_from_position(::chess::standard::Position* from_position);
  private:
  const ::chess::standard::Position& _internal_from_position() const;
  ::chess::standard::Position* _internal_mutable_from_position();
  public:
  void unsafe_arena_set_allocated_from_position(
      ::chess::standard::Position* from_position);
  ::chess::standard::Position* unsafe_arena_release_from_position();

  // .chess.standard.Position to_position = 3;
  bool has_to_position() const;
  private:
  bool _internal_has_to_position() const;
  public:
  void clear_to_position();
  const ::chess::standard::Position& to_position() const;
  PROTOBUF_NODISCARD ::chess::standard::Position* release_to_position();
  ::chess::standard::Position* mutable_to_position();
  void set_allocated_to_position(::chess::standard::Position* to_position);
  private:
  const ::chess::standard::Position& _internal_to_position() const;
  ::chess::standard::Position* _internal_mutable_to_position();
  public:
  void unsafe_arena_set_allocated_to_position(
      ::chess::standard::Position* to_position);
  ::chess::standard::Position* unsafe_arena_release_to_position();

  // int32 piece_id = 1;
  void clear_piece_id();
  int32_t piece_id() const;
  void set_piece_id(int32_t value);
  private:
  int32_t _internal_piece_id() const;
  void _internal_set_piece_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chess.standard.Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::chess::standard::Position* from_position_;
    ::chess::standard::Position* to_position_;
    int32_t piece_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chess_2eproto;
};
// -------------------------------------------------------------------

class MoveMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chess.standard.MoveMessage) */ {
 public:
  inline MoveMessage() : MoveMessage(nullptr) {}
  ~MoveMessage() override;
  explicit PROTOBUF_CONSTEXPR MoveMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveMessage(const MoveMessage& from);
  MoveMessage(MoveMessage&& from) noexcept
    : MoveMessage() {
    *this = ::std::move(from);
  }

  inline MoveMessage& operator=(const MoveMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveMessage& operator=(MoveMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveMessage* internal_default_instance() {
    return reinterpret_cast<const MoveMessage*>(
               &_MoveMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MoveMessage& a, MoveMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveMessage& from) {
    MoveMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chess.standard.MoveMessage";
  }
  protected:
  explicit MoveMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMoveFieldNumber = 1,
  };
  // .chess.standard.Move move = 1;
  bool has_move() const;
  private:
  bool _internal_has_move() const;
  public:
  void clear_move();
  const ::chess::standard::Move& move() const;
  PROTOBUF_NODISCARD ::chess::standard::Move* release_move();
  ::chess::standard::Move* mutable_move();
  void set_allocated_move(::chess::standard::Move* move);
  private:
  const ::chess::standard::Move& _internal_move() const;
  ::chess::standard::Move* _internal_mutable_move();
  public:
  void unsafe_arena_set_allocated_move(
      ::chess::standard::Move* move);
  ::chess::standard::Move* unsafe_arena_release_move();

  // @@protoc_insertion_point(class_scope:chess.standard.MoveMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::chess::standard::Move* move_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chess_2eproto;
};
// -------------------------------------------------------------------

class MoveResultMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chess.standard.MoveResultMessage) */ {
 public:
  inline MoveResultMessage() : MoveResultMessage(nullptr) {}
  ~MoveResultMessage() override;
  explicit PROTOBUF_CONSTEXPR MoveResultMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveResultMessage(const MoveResultMessage& from);
  MoveResultMessage(MoveResultMessage&& from) noexcept
    : MoveResultMessage() {
    *this = ::std::move(from);
  }

  inline MoveResultMessage& operator=(const MoveResultMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveResultMessage& operator=(MoveResultMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveResultMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveResultMessage* internal_default_instance() {
    return reinterpret_cast<const MoveResultMessage*>(
               &_MoveResultMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MoveResultMessage& a, MoveResultMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveResultMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveResultMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveResultMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveResultMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveResultMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveResultMessage& from) {
    MoveResultMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveResultMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chess.standard.MoveResultMessage";
  }
  protected:
  explicit MoveResultMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMoveFieldNumber = 1,
    kBoardStateFieldNumber = 2,
    kValidFieldNumber = 3,
    kErrorCodeFieldNumber = 4,
  };
  // .chess.standard.Move move = 1;
  bool has_move() const;
  private:
  bool _internal_has_move() const;
  public:
  void clear_move();
  const ::chess::standard::Move& move() const;
  PROTOBUF_NODISCARD ::chess::standard::Move* release_move();
  ::chess::standard::Move* mutable_move();
  void set_allocated_move(::chess::standard::Move* move);
  private:
  const ::chess::standard::Move& _internal_move() const;
  ::chess::standard::Move* _internal_mutable_move();
  public:
  void unsafe_arena_set_allocated_move(
      ::chess::standard::Move* move);
  ::chess::standard::Move* unsafe_arena_release_move();

  // .chess.standard.BoardState board_state = 2;
  bool has_board_state() const;
  private:
  bool _internal_has_board_state() const;
  public:
  void clear_board_state();
  const ::chess::standard::BoardState& board_state() const;
  PROTOBUF_NODISCARD ::chess::standard::BoardState* release_board_state();
  ::chess::standard::BoardState* mutable_board_state();
  void set_allocated_board_state(::chess::standard::BoardState* board_state);
  private:
  const ::chess::standard::BoardState& _internal_board_state() const;
  ::chess::standard::BoardState* _internal_mutable_board_state();
  public:
  void unsafe_arena_set_allocated_board_state(
      ::chess::standard::BoardState* board_state);
  ::chess::standard::BoardState* unsafe_arena_release_board_state();

  // bool valid = 3;
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // uint32 error_code = 4;
  void clear_error_code();
  uint32_t error_code() const;
  void set_error_code(uint32_t value);
  private:
  uint32_t _internal_error_code() const;
  void _internal_set_error_code(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chess.standard.MoveResultMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::chess::standard::Move* move_;
    ::chess::standard::BoardState* board_state_;
    bool valid_;
    uint32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chess_2eproto;
};
// -------------------------------------------------------------------

class GameOverMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chess.standard.GameOverMessage) */ {
 public:
  inline GameOverMessage() : GameOverMessage(nullptr) {}
  ~GameOverMessage() override;
  explicit PROTOBUF_CONSTEXPR GameOverMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameOverMessage(const GameOverMessage& from);
  GameOverMessage(GameOverMessage&& from) noexcept
    : GameOverMessage() {
    *this = ::std::move(from);
  }

  inline GameOverMessage& operator=(const GameOverMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameOverMessage& operator=(GameOverMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameOverMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameOverMessage* internal_default_instance() {
    return reinterpret_cast<const GameOverMessage*>(
               &_GameOverMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GameOverMessage& a, GameOverMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameOverMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameOverMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameOverMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameOverMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameOverMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameOverMessage& from) {
    GameOverMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameOverMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chess.standard.GameOverMessage";
  }
  protected:
  explicit GameOverMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWinnerColorFieldNumber = 1,
    kReasonFieldNumber = 2,
  };
  // .chess.standard.PieceColor winner_color = 1;
  void clear_winner_color();
  ::chess::standard::PieceColor winner_color() const;
  void set_winner_color(::chess::standard::PieceColor value);
  private:
  ::chess::standard::PieceColor _internal_winner_color() const;
  void _internal_set_winner_color(::chess::standard::PieceColor value);
  public:

  // .chess.standard.GameEndReason reason = 2;
  void clear_reason();
  ::chess::standard::GameEndReason reason() const;
  void set_reason(::chess::standard::GameEndReason value);
  private:
  ::chess::standard::GameEndReason _internal_reason() const;
  void _internal_set_reason(::chess::standard::GameEndReason value);
  public:

  // @@protoc_insertion_point(class_scope:chess.standard.GameOverMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int winner_color_;
    int reason_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chess_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chess.standard.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  enum ContentCase {
    kMoveMessage = 2,
    kMoveResultMessage = 3,
    kGameOverMessage = 4,
    CONTENT_NOT_SET = 0,
  };

  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chess.standard.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypeFieldNumber = 1,
    kMoveMessageFieldNumber = 2,
    kMoveResultMessageFieldNumber = 3,
    kGameOverMessageFieldNumber = 4,
  };
  // .chess.standard.MessageType message_type = 1;
  void clear_message_type();
  ::chess::standard::MessageType message_type() const;
  void set_message_type(::chess::standard::MessageType value);
  private:
  ::chess::standard::MessageType _internal_message_type() const;
  void _internal_set_message_type(::chess::standard::MessageType value);
  public:

  // .chess.standard.MoveMessage move_message = 2;
  bool has_move_message() const;
  private:
  bool _internal_has_move_message() const;
  public:
  void clear_move_message();
  const ::chess::standard::MoveMessage& move_message() const;
  PROTOBUF_NODISCARD ::chess::standard::MoveMessage* release_move_message();
  ::chess::standard::MoveMessage* mutable_move_message();
  void set_allocated_move_message(::chess::standard::MoveMessage* move_message);
  private:
  const ::chess::standard::MoveMessage& _internal_move_message() const;
  ::chess::standard::MoveMessage* _internal_mutable_move_message();
  public:
  void unsafe_arena_set_allocated_move_message(
      ::chess::standard::MoveMessage* move_message);
  ::chess::standard::MoveMessage* unsafe_arena_release_move_message();

  // .chess.standard.MoveResultMessage move_result_message = 3;
  bool has_move_result_message() const;
  private:
  bool _internal_has_move_result_message() const;
  public:
  void clear_move_result_message();
  const ::chess::standard::MoveResultMessage& move_result_message() const;
  PROTOBUF_NODISCARD ::chess::standard::MoveResultMessage* release_move_result_message();
  ::chess::standard::MoveResultMessage* mutable_move_result_message();
  void set_allocated_move_result_message(::chess::standard::MoveResultMessage* move_result_message);
  private:
  const ::chess::standard::MoveResultMessage& _internal_move_result_message() const;
  ::chess::standard::MoveResultMessage* _internal_mutable_move_result_message();
  public:
  void unsafe_arena_set_allocated_move_result_message(
      ::chess::standard::MoveResultMessage* move_result_message);
  ::chess::standard::MoveResultMessage* unsafe_arena_release_move_result_message();

  // .chess.standard.GameOverMessage game_over_message = 4;
  bool has_game_over_message() const;
  private:
  bool _internal_has_game_over_message() const;
  public:
  void clear_game_over_message();
  const ::chess::standard::GameOverMessage& game_over_message() const;
  PROTOBUF_NODISCARD ::chess::standard::GameOverMessage* release_game_over_message();
  ::chess::standard::GameOverMessage* mutable_game_over_message();
  void set_allocated_game_over_message(::chess::standard::GameOverMessage* game_over_message);
  private:
  const ::chess::standard::GameOverMessage& _internal_game_over_message() const;
  ::chess::standard::GameOverMessage* _internal_mutable_game_over_message();
  public:
  void unsafe_arena_set_allocated_game_over_message(
      ::chess::standard::GameOverMessage* game_over_message);
  ::chess::standard::GameOverMessage* unsafe_arena_release_game_over_message();

  void clear_content();
  ContentCase content_case() const;
  // @@protoc_insertion_point(class_scope:chess.standard.Message)
 private:
  class _Internal;
  void set_has_move_message();
  void set_has_move_result_message();
  void set_has_game_over_message();

  inline bool has_content() const;
  inline void clear_has_content();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int message_type_;
    union ContentUnion {
      constexpr ContentUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::chess::standard::MoveMessage* move_message_;
      ::chess::standard::MoveResultMessage* move_result_message_;
      ::chess::standard::GameOverMessage* game_over_message_;
    } content_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chess_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Position

// int32 x = 1;
inline void Position::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t Position::_internal_x() const {
  return _impl_.x_;
}
inline int32_t Position::x() const {
  // @@protoc_insertion_point(field_get:chess.standard.Position.x)
  return _internal_x();
}
inline void Position::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void Position::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:chess.standard.Position.x)
}

// int32 y = 2;
inline void Position::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t Position::_internal_y() const {
  return _impl_.y_;
}
inline int32_t Position::y() const {
  // @@protoc_insertion_point(field_get:chess.standard.Position.y)
  return _internal_y();
}
inline void Position::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void Position::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:chess.standard.Position.y)
}

// -------------------------------------------------------------------

// Piece

// int32 id = 1;
inline void Piece::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Piece::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Piece::id() const {
  // @@protoc_insertion_point(field_get:chess.standard.Piece.id)
  return _internal_id();
}
inline void Piece::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Piece::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:chess.standard.Piece.id)
}

// .chess.standard.PieceType piece_type = 2;
inline void Piece::clear_piece_type() {
  _impl_.piece_type_ = 0;
}
inline ::chess::standard::PieceType Piece::_internal_piece_type() const {
  return static_cast< ::chess::standard::PieceType >(_impl_.piece_type_);
}
inline ::chess::standard::PieceType Piece::piece_type() const {
  // @@protoc_insertion_point(field_get:chess.standard.Piece.piece_type)
  return _internal_piece_type();
}
inline void Piece::_internal_set_piece_type(::chess::standard::PieceType value) {
  
  _impl_.piece_type_ = value;
}
inline void Piece::set_piece_type(::chess::standard::PieceType value) {
  _internal_set_piece_type(value);
  // @@protoc_insertion_point(field_set:chess.standard.Piece.piece_type)
}

// .chess.standard.PieceColor color = 3;
inline void Piece::clear_color() {
  _impl_.color_ = 0;
}
inline ::chess::standard::PieceColor Piece::_internal_color() const {
  return static_cast< ::chess::standard::PieceColor >(_impl_.color_);
}
inline ::chess::standard::PieceColor Piece::color() const {
  // @@protoc_insertion_point(field_get:chess.standard.Piece.color)
  return _internal_color();
}
inline void Piece::_internal_set_color(::chess::standard::PieceColor value) {
  
  _impl_.color_ = value;
}
inline void Piece::set_color(::chess::standard::PieceColor value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:chess.standard.Piece.color)
}

// .chess.standard.Position position = 4;
inline bool Piece::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool Piece::has_position() const {
  return _internal_has_position();
}
inline void Piece::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::chess::standard::Position& Piece::_internal_position() const {
  const ::chess::standard::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::chess::standard::Position&>(
      ::chess::standard::_Position_default_instance_);
}
inline const ::chess::standard::Position& Piece::position() const {
  // @@protoc_insertion_point(field_get:chess.standard.Piece.position)
  return _internal_position();
}
inline void Piece::unsafe_arena_set_allocated_position(
    ::chess::standard::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chess.standard.Piece.position)
}
inline ::chess::standard::Position* Piece::release_position() {
  
  ::chess::standard::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chess::standard::Position* Piece::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:chess.standard.Piece.position)
  
  ::chess::standard::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::chess::standard::Position* Piece::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::chess::standard::Position>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::chess::standard::Position* Piece::mutable_position() {
  ::chess::standard::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:chess.standard.Piece.position)
  return _msg;
}
inline void Piece::set_allocated_position(::chess::standard::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:chess.standard.Piece.position)
}

// -------------------------------------------------------------------

// BoardState

// repeated .chess.standard.Piece pieces = 1;
inline int BoardState::_internal_pieces_size() const {
  return _impl_.pieces_.size();
}
inline int BoardState::pieces_size() const {
  return _internal_pieces_size();
}
inline void BoardState::clear_pieces() {
  _impl_.pieces_.Clear();
}
inline ::chess::standard::Piece* BoardState::mutable_pieces(int index) {
  // @@protoc_insertion_point(field_mutable:chess.standard.BoardState.pieces)
  return _impl_.pieces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chess::standard::Piece >*
BoardState::mutable_pieces() {
  // @@protoc_insertion_point(field_mutable_list:chess.standard.BoardState.pieces)
  return &_impl_.pieces_;
}
inline const ::chess::standard::Piece& BoardState::_internal_pieces(int index) const {
  return _impl_.pieces_.Get(index);
}
inline const ::chess::standard::Piece& BoardState::pieces(int index) const {
  // @@protoc_insertion_point(field_get:chess.standard.BoardState.pieces)
  return _internal_pieces(index);
}
inline ::chess::standard::Piece* BoardState::_internal_add_pieces() {
  return _impl_.pieces_.Add();
}
inline ::chess::standard::Piece* BoardState::add_pieces() {
  ::chess::standard::Piece* _add = _internal_add_pieces();
  // @@protoc_insertion_point(field_add:chess.standard.BoardState.pieces)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chess::standard::Piece >&
BoardState::pieces() const {
  // @@protoc_insertion_point(field_list:chess.standard.BoardState.pieces)
  return _impl_.pieces_;
}

// -------------------------------------------------------------------

// Move

// int32 piece_id = 1;
inline void Move::clear_piece_id() {
  _impl_.piece_id_ = 0;
}
inline int32_t Move::_internal_piece_id() const {
  return _impl_.piece_id_;
}
inline int32_t Move::piece_id() const {
  // @@protoc_insertion_point(field_get:chess.standard.Move.piece_id)
  return _internal_piece_id();
}
inline void Move::_internal_set_piece_id(int32_t value) {
  
  _impl_.piece_id_ = value;
}
inline void Move::set_piece_id(int32_t value) {
  _internal_set_piece_id(value);
  // @@protoc_insertion_point(field_set:chess.standard.Move.piece_id)
}

// .chess.standard.Position from_position = 2;
inline bool Move::_internal_has_from_position() const {
  return this != internal_default_instance() && _impl_.from_position_ != nullptr;
}
inline bool Move::has_from_position() const {
  return _internal_has_from_position();
}
inline void Move::clear_from_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.from_position_ != nullptr) {
    delete _impl_.from_position_;
  }
  _impl_.from_position_ = nullptr;
}
inline const ::chess::standard::Position& Move::_internal_from_position() const {
  const ::chess::standard::Position* p = _impl_.from_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::chess::standard::Position&>(
      ::chess::standard::_Position_default_instance_);
}
inline const ::chess::standard::Position& Move::from_position() const {
  // @@protoc_insertion_point(field_get:chess.standard.Move.from_position)
  return _internal_from_position();
}
inline void Move::unsafe_arena_set_allocated_from_position(
    ::chess::standard::Position* from_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.from_position_);
  }
  _impl_.from_position_ = from_position;
  if (from_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chess.standard.Move.from_position)
}
inline ::chess::standard::Position* Move::release_from_position() {
  
  ::chess::standard::Position* temp = _impl_.from_position_;
  _impl_.from_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chess::standard::Position* Move::unsafe_arena_release_from_position() {
  // @@protoc_insertion_point(field_release:chess.standard.Move.from_position)
  
  ::chess::standard::Position* temp = _impl_.from_position_;
  _impl_.from_position_ = nullptr;
  return temp;
}
inline ::chess::standard::Position* Move::_internal_mutable_from_position() {
  
  if (_impl_.from_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::chess::standard::Position>(GetArenaForAllocation());
    _impl_.from_position_ = p;
  }
  return _impl_.from_position_;
}
inline ::chess::standard::Position* Move::mutable_from_position() {
  ::chess::standard::Position* _msg = _internal_mutable_from_position();
  // @@protoc_insertion_point(field_mutable:chess.standard.Move.from_position)
  return _msg;
}
inline void Move::set_allocated_from_position(::chess::standard::Position* from_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.from_position_;
  }
  if (from_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(from_position);
    if (message_arena != submessage_arena) {
      from_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from_position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.from_position_ = from_position;
  // @@protoc_insertion_point(field_set_allocated:chess.standard.Move.from_position)
}

// .chess.standard.Position to_position = 3;
inline bool Move::_internal_has_to_position() const {
  return this != internal_default_instance() && _impl_.to_position_ != nullptr;
}
inline bool Move::has_to_position() const {
  return _internal_has_to_position();
}
inline void Move::clear_to_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.to_position_ != nullptr) {
    delete _impl_.to_position_;
  }
  _impl_.to_position_ = nullptr;
}
inline const ::chess::standard::Position& Move::_internal_to_position() const {
  const ::chess::standard::Position* p = _impl_.to_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::chess::standard::Position&>(
      ::chess::standard::_Position_default_instance_);
}
inline const ::chess::standard::Position& Move::to_position() const {
  // @@protoc_insertion_point(field_get:chess.standard.Move.to_position)
  return _internal_to_position();
}
inline void Move::unsafe_arena_set_allocated_to_position(
    ::chess::standard::Position* to_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.to_position_);
  }
  _impl_.to_position_ = to_position;
  if (to_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chess.standard.Move.to_position)
}
inline ::chess::standard::Position* Move::release_to_position() {
  
  ::chess::standard::Position* temp = _impl_.to_position_;
  _impl_.to_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chess::standard::Position* Move::unsafe_arena_release_to_position() {
  // @@protoc_insertion_point(field_release:chess.standard.Move.to_position)
  
  ::chess::standard::Position* temp = _impl_.to_position_;
  _impl_.to_position_ = nullptr;
  return temp;
}
inline ::chess::standard::Position* Move::_internal_mutable_to_position() {
  
  if (_impl_.to_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::chess::standard::Position>(GetArenaForAllocation());
    _impl_.to_position_ = p;
  }
  return _impl_.to_position_;
}
inline ::chess::standard::Position* Move::mutable_to_position() {
  ::chess::standard::Position* _msg = _internal_mutable_to_position();
  // @@protoc_insertion_point(field_mutable:chess.standard.Move.to_position)
  return _msg;
}
inline void Move::set_allocated_to_position(::chess::standard::Position* to_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.to_position_;
  }
  if (to_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(to_position);
    if (message_arena != submessage_arena) {
      to_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to_position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.to_position_ = to_position;
  // @@protoc_insertion_point(field_set_allocated:chess.standard.Move.to_position)
}

// -------------------------------------------------------------------

// MoveMessage

// .chess.standard.Move move = 1;
inline bool MoveMessage::_internal_has_move() const {
  return this != internal_default_instance() && _impl_.move_ != nullptr;
}
inline bool MoveMessage::has_move() const {
  return _internal_has_move();
}
inline void MoveMessage::clear_move() {
  if (GetArenaForAllocation() == nullptr && _impl_.move_ != nullptr) {
    delete _impl_.move_;
  }
  _impl_.move_ = nullptr;
}
inline const ::chess::standard::Move& MoveMessage::_internal_move() const {
  const ::chess::standard::Move* p = _impl_.move_;
  return p != nullptr ? *p : reinterpret_cast<const ::chess::standard::Move&>(
      ::chess::standard::_Move_default_instance_);
}
inline const ::chess::standard::Move& MoveMessage::move() const {
  // @@protoc_insertion_point(field_get:chess.standard.MoveMessage.move)
  return _internal_move();
}
inline void MoveMessage::unsafe_arena_set_allocated_move(
    ::chess::standard::Move* move) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.move_);
  }
  _impl_.move_ = move;
  if (move) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chess.standard.MoveMessage.move)
}
inline ::chess::standard::Move* MoveMessage::release_move() {
  
  ::chess::standard::Move* temp = _impl_.move_;
  _impl_.move_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chess::standard::Move* MoveMessage::unsafe_arena_release_move() {
  // @@protoc_insertion_point(field_release:chess.standard.MoveMessage.move)
  
  ::chess::standard::Move* temp = _impl_.move_;
  _impl_.move_ = nullptr;
  return temp;
}
inline ::chess::standard::Move* MoveMessage::_internal_mutable_move() {
  
  if (_impl_.move_ == nullptr) {
    auto* p = CreateMaybeMessage<::chess::standard::Move>(GetArenaForAllocation());
    _impl_.move_ = p;
  }
  return _impl_.move_;
}
inline ::chess::standard::Move* MoveMessage::mutable_move() {
  ::chess::standard::Move* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:chess.standard.MoveMessage.move)
  return _msg;
}
inline void MoveMessage::set_allocated_move(::chess::standard::Move* move) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.move_;
  }
  if (move) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(move);
    if (message_arena != submessage_arena) {
      move = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, move, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.move_ = move;
  // @@protoc_insertion_point(field_set_allocated:chess.standard.MoveMessage.move)
}

// -------------------------------------------------------------------

// MoveResultMessage

// .chess.standard.Move move = 1;
inline bool MoveResultMessage::_internal_has_move() const {
  return this != internal_default_instance() && _impl_.move_ != nullptr;
}
inline bool MoveResultMessage::has_move() const {
  return _internal_has_move();
}
inline void MoveResultMessage::clear_move() {
  if (GetArenaForAllocation() == nullptr && _impl_.move_ != nullptr) {
    delete _impl_.move_;
  }
  _impl_.move_ = nullptr;
}
inline const ::chess::standard::Move& MoveResultMessage::_internal_move() const {
  const ::chess::standard::Move* p = _impl_.move_;
  return p != nullptr ? *p : reinterpret_cast<const ::chess::standard::Move&>(
      ::chess::standard::_Move_default_instance_);
}
inline const ::chess::standard::Move& MoveResultMessage::move() const {
  // @@protoc_insertion_point(field_get:chess.standard.MoveResultMessage.move)
  return _internal_move();
}
inline void MoveResultMessage::unsafe_arena_set_allocated_move(
    ::chess::standard::Move* move) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.move_);
  }
  _impl_.move_ = move;
  if (move) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chess.standard.MoveResultMessage.move)
}
inline ::chess::standard::Move* MoveResultMessage::release_move() {
  
  ::chess::standard::Move* temp = _impl_.move_;
  _impl_.move_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chess::standard::Move* MoveResultMessage::unsafe_arena_release_move() {
  // @@protoc_insertion_point(field_release:chess.standard.MoveResultMessage.move)
  
  ::chess::standard::Move* temp = _impl_.move_;
  _impl_.move_ = nullptr;
  return temp;
}
inline ::chess::standard::Move* MoveResultMessage::_internal_mutable_move() {
  
  if (_impl_.move_ == nullptr) {
    auto* p = CreateMaybeMessage<::chess::standard::Move>(GetArenaForAllocation());
    _impl_.move_ = p;
  }
  return _impl_.move_;
}
inline ::chess::standard::Move* MoveResultMessage::mutable_move() {
  ::chess::standard::Move* _msg = _internal_mutable_move();
  // @@protoc_insertion_point(field_mutable:chess.standard.MoveResultMessage.move)
  return _msg;
}
inline void MoveResultMessage::set_allocated_move(::chess::standard::Move* move) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.move_;
  }
  if (move) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(move);
    if (message_arena != submessage_arena) {
      move = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, move, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.move_ = move;
  // @@protoc_insertion_point(field_set_allocated:chess.standard.MoveResultMessage.move)
}

// .chess.standard.BoardState board_state = 2;
inline bool MoveResultMessage::_internal_has_board_state() const {
  return this != internal_default_instance() && _impl_.board_state_ != nullptr;
}
inline bool MoveResultMessage::has_board_state() const {
  return _internal_has_board_state();
}
inline void MoveResultMessage::clear_board_state() {
  if (GetArenaForAllocation() == nullptr && _impl_.board_state_ != nullptr) {
    delete _impl_.board_state_;
  }
  _impl_.board_state_ = nullptr;
}
inline const ::chess::standard::BoardState& MoveResultMessage::_internal_board_state() const {
  const ::chess::standard::BoardState* p = _impl_.board_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::chess::standard::BoardState&>(
      ::chess::standard::_BoardState_default_instance_);
}
inline const ::chess::standard::BoardState& MoveResultMessage::board_state() const {
  // @@protoc_insertion_point(field_get:chess.standard.MoveResultMessage.board_state)
  return _internal_board_state();
}
inline void MoveResultMessage::unsafe_arena_set_allocated_board_state(
    ::chess::standard::BoardState* board_state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.board_state_);
  }
  _impl_.board_state_ = board_state;
  if (board_state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chess.standard.MoveResultMessage.board_state)
}
inline ::chess::standard::BoardState* MoveResultMessage::release_board_state() {
  
  ::chess::standard::BoardState* temp = _impl_.board_state_;
  _impl_.board_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chess::standard::BoardState* MoveResultMessage::unsafe_arena_release_board_state() {
  // @@protoc_insertion_point(field_release:chess.standard.MoveResultMessage.board_state)
  
  ::chess::standard::BoardState* temp = _impl_.board_state_;
  _impl_.board_state_ = nullptr;
  return temp;
}
inline ::chess::standard::BoardState* MoveResultMessage::_internal_mutable_board_state() {
  
  if (_impl_.board_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::chess::standard::BoardState>(GetArenaForAllocation());
    _impl_.board_state_ = p;
  }
  return _impl_.board_state_;
}
inline ::chess::standard::BoardState* MoveResultMessage::mutable_board_state() {
  ::chess::standard::BoardState* _msg = _internal_mutable_board_state();
  // @@protoc_insertion_point(field_mutable:chess.standard.MoveResultMessage.board_state)
  return _msg;
}
inline void MoveResultMessage::set_allocated_board_state(::chess::standard::BoardState* board_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.board_state_;
  }
  if (board_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(board_state);
    if (message_arena != submessage_arena) {
      board_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, board_state, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.board_state_ = board_state;
  // @@protoc_insertion_point(field_set_allocated:chess.standard.MoveResultMessage.board_state)
}

// bool valid = 3;
inline void MoveResultMessage::clear_valid() {
  _impl_.valid_ = false;
}
inline bool MoveResultMessage::_internal_valid() const {
  return _impl_.valid_;
}
inline bool MoveResultMessage::valid() const {
  // @@protoc_insertion_point(field_get:chess.standard.MoveResultMessage.valid)
  return _internal_valid();
}
inline void MoveResultMessage::_internal_set_valid(bool value) {
  
  _impl_.valid_ = value;
}
inline void MoveResultMessage::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:chess.standard.MoveResultMessage.valid)
}

// uint32 error_code = 4;
inline void MoveResultMessage::clear_error_code() {
  _impl_.error_code_ = 0u;
}
inline uint32_t MoveResultMessage::_internal_error_code() const {
  return _impl_.error_code_;
}
inline uint32_t MoveResultMessage::error_code() const {
  // @@protoc_insertion_point(field_get:chess.standard.MoveResultMessage.error_code)
  return _internal_error_code();
}
inline void MoveResultMessage::_internal_set_error_code(uint32_t value) {
  
  _impl_.error_code_ = value;
}
inline void MoveResultMessage::set_error_code(uint32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:chess.standard.MoveResultMessage.error_code)
}

// -------------------------------------------------------------------

// GameOverMessage

// .chess.standard.PieceColor winner_color = 1;
inline void GameOverMessage::clear_winner_color() {
  _impl_.winner_color_ = 0;
}
inline ::chess::standard::PieceColor GameOverMessage::_internal_winner_color() const {
  return static_cast< ::chess::standard::PieceColor >(_impl_.winner_color_);
}
inline ::chess::standard::PieceColor GameOverMessage::winner_color() const {
  // @@protoc_insertion_point(field_get:chess.standard.GameOverMessage.winner_color)
  return _internal_winner_color();
}
inline void GameOverMessage::_internal_set_winner_color(::chess::standard::PieceColor value) {
  
  _impl_.winner_color_ = value;
}
inline void GameOverMessage::set_winner_color(::chess::standard::PieceColor value) {
  _internal_set_winner_color(value);
  // @@protoc_insertion_point(field_set:chess.standard.GameOverMessage.winner_color)
}

// .chess.standard.GameEndReason reason = 2;
inline void GameOverMessage::clear_reason() {
  _impl_.reason_ = 0;
}
inline ::chess::standard::GameEndReason GameOverMessage::_internal_reason() const {
  return static_cast< ::chess::standard::GameEndReason >(_impl_.reason_);
}
inline ::chess::standard::GameEndReason GameOverMessage::reason() const {
  // @@protoc_insertion_point(field_get:chess.standard.GameOverMessage.reason)
  return _internal_reason();
}
inline void GameOverMessage::_internal_set_reason(::chess::standard::GameEndReason value) {
  
  _impl_.reason_ = value;
}
inline void GameOverMessage::set_reason(::chess::standard::GameEndReason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:chess.standard.GameOverMessage.reason)
}

// -------------------------------------------------------------------

// Message

// .chess.standard.MessageType message_type = 1;
inline void Message::clear_message_type() {
  _impl_.message_type_ = 0;
}
inline ::chess::standard::MessageType Message::_internal_message_type() const {
  return static_cast< ::chess::standard::MessageType >(_impl_.message_type_);
}
inline ::chess::standard::MessageType Message::message_type() const {
  // @@protoc_insertion_point(field_get:chess.standard.Message.message_type)
  return _internal_message_type();
}
inline void Message::_internal_set_message_type(::chess::standard::MessageType value) {
  
  _impl_.message_type_ = value;
}
inline void Message::set_message_type(::chess::standard::MessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:chess.standard.Message.message_type)
}

// .chess.standard.MoveMessage move_message = 2;
inline bool Message::_internal_has_move_message() const {
  return content_case() == kMoveMessage;
}
inline bool Message::has_move_message() const {
  return _internal_has_move_message();
}
inline void Message::set_has_move_message() {
  _impl_._oneof_case_[0] = kMoveMessage;
}
inline void Message::clear_move_message() {
  if (_internal_has_move_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.content_.move_message_;
    }
    clear_has_content();
  }
}
inline ::chess::standard::MoveMessage* Message::release_move_message() {
  // @@protoc_insertion_point(field_release:chess.standard.Message.move_message)
  if (_internal_has_move_message()) {
    clear_has_content();
    ::chess::standard::MoveMessage* temp = _impl_.content_.move_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.move_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chess::standard::MoveMessage& Message::_internal_move_message() const {
  return _internal_has_move_message()
      ? *_impl_.content_.move_message_
      : reinterpret_cast< ::chess::standard::MoveMessage&>(::chess::standard::_MoveMessage_default_instance_);
}
inline const ::chess::standard::MoveMessage& Message::move_message() const {
  // @@protoc_insertion_point(field_get:chess.standard.Message.move_message)
  return _internal_move_message();
}
inline ::chess::standard::MoveMessage* Message::unsafe_arena_release_move_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chess.standard.Message.move_message)
  if (_internal_has_move_message()) {
    clear_has_content();
    ::chess::standard::MoveMessage* temp = _impl_.content_.move_message_;
    _impl_.content_.move_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_move_message(::chess::standard::MoveMessage* move_message) {
  clear_content();
  if (move_message) {
    set_has_move_message();
    _impl_.content_.move_message_ = move_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chess.standard.Message.move_message)
}
inline ::chess::standard::MoveMessage* Message::_internal_mutable_move_message() {
  if (!_internal_has_move_message()) {
    clear_content();
    set_has_move_message();
    _impl_.content_.move_message_ = CreateMaybeMessage< ::chess::standard::MoveMessage >(GetArenaForAllocation());
  }
  return _impl_.content_.move_message_;
}
inline ::chess::standard::MoveMessage* Message::mutable_move_message() {
  ::chess::standard::MoveMessage* _msg = _internal_mutable_move_message();
  // @@protoc_insertion_point(field_mutable:chess.standard.Message.move_message)
  return _msg;
}

// .chess.standard.MoveResultMessage move_result_message = 3;
inline bool Message::_internal_has_move_result_message() const {
  return content_case() == kMoveResultMessage;
}
inline bool Message::has_move_result_message() const {
  return _internal_has_move_result_message();
}
inline void Message::set_has_move_result_message() {
  _impl_._oneof_case_[0] = kMoveResultMessage;
}
inline void Message::clear_move_result_message() {
  if (_internal_has_move_result_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.content_.move_result_message_;
    }
    clear_has_content();
  }
}
inline ::chess::standard::MoveResultMessage* Message::release_move_result_message() {
  // @@protoc_insertion_point(field_release:chess.standard.Message.move_result_message)
  if (_internal_has_move_result_message()) {
    clear_has_content();
    ::chess::standard::MoveResultMessage* temp = _impl_.content_.move_result_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.move_result_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chess::standard::MoveResultMessage& Message::_internal_move_result_message() const {
  return _internal_has_move_result_message()
      ? *_impl_.content_.move_result_message_
      : reinterpret_cast< ::chess::standard::MoveResultMessage&>(::chess::standard::_MoveResultMessage_default_instance_);
}
inline const ::chess::standard::MoveResultMessage& Message::move_result_message() const {
  // @@protoc_insertion_point(field_get:chess.standard.Message.move_result_message)
  return _internal_move_result_message();
}
inline ::chess::standard::MoveResultMessage* Message::unsafe_arena_release_move_result_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chess.standard.Message.move_result_message)
  if (_internal_has_move_result_message()) {
    clear_has_content();
    ::chess::standard::MoveResultMessage* temp = _impl_.content_.move_result_message_;
    _impl_.content_.move_result_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_move_result_message(::chess::standard::MoveResultMessage* move_result_message) {
  clear_content();
  if (move_result_message) {
    set_has_move_result_message();
    _impl_.content_.move_result_message_ = move_result_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chess.standard.Message.move_result_message)
}
inline ::chess::standard::MoveResultMessage* Message::_internal_mutable_move_result_message() {
  if (!_internal_has_move_result_message()) {
    clear_content();
    set_has_move_result_message();
    _impl_.content_.move_result_message_ = CreateMaybeMessage< ::chess::standard::MoveResultMessage >(GetArenaForAllocation());
  }
  return _impl_.content_.move_result_message_;
}
inline ::chess::standard::MoveResultMessage* Message::mutable_move_result_message() {
  ::chess::standard::MoveResultMessage* _msg = _internal_mutable_move_result_message();
  // @@protoc_insertion_point(field_mutable:chess.standard.Message.move_result_message)
  return _msg;
}

// .chess.standard.GameOverMessage game_over_message = 4;
inline bool Message::_internal_has_game_over_message() const {
  return content_case() == kGameOverMessage;
}
inline bool Message::has_game_over_message() const {
  return _internal_has_game_over_message();
}
inline void Message::set_has_game_over_message() {
  _impl_._oneof_case_[0] = kGameOverMessage;
}
inline void Message::clear_game_over_message() {
  if (_internal_has_game_over_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.content_.game_over_message_;
    }
    clear_has_content();
  }
}
inline ::chess::standard::GameOverMessage* Message::release_game_over_message() {
  // @@protoc_insertion_point(field_release:chess.standard.Message.game_over_message)
  if (_internal_has_game_over_message()) {
    clear_has_content();
    ::chess::standard::GameOverMessage* temp = _impl_.content_.game_over_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.content_.game_over_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::chess::standard::GameOverMessage& Message::_internal_game_over_message() const {
  return _internal_has_game_over_message()
      ? *_impl_.content_.game_over_message_
      : reinterpret_cast< ::chess::standard::GameOverMessage&>(::chess::standard::_GameOverMessage_default_instance_);
}
inline const ::chess::standard::GameOverMessage& Message::game_over_message() const {
  // @@protoc_insertion_point(field_get:chess.standard.Message.game_over_message)
  return _internal_game_over_message();
}
inline ::chess::standard::GameOverMessage* Message::unsafe_arena_release_game_over_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chess.standard.Message.game_over_message)
  if (_internal_has_game_over_message()) {
    clear_has_content();
    ::chess::standard::GameOverMessage* temp = _impl_.content_.game_over_message_;
    _impl_.content_.game_over_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_game_over_message(::chess::standard::GameOverMessage* game_over_message) {
  clear_content();
  if (game_over_message) {
    set_has_game_over_message();
    _impl_.content_.game_over_message_ = game_over_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chess.standard.Message.game_over_message)
}
inline ::chess::standard::GameOverMessage* Message::_internal_mutable_game_over_message() {
  if (!_internal_has_game_over_message()) {
    clear_content();
    set_has_game_over_message();
    _impl_.content_.game_over_message_ = CreateMaybeMessage< ::chess::standard::GameOverMessage >(GetArenaForAllocation());
  }
  return _impl_.content_.game_over_message_;
}
inline ::chess::standard::GameOverMessage* Message::mutable_game_over_message() {
  ::chess::standard::GameOverMessage* _msg = _internal_mutable_game_over_message();
  // @@protoc_insertion_point(field_mutable:chess.standard.Message.game_over_message)
  return _msg;
}

inline bool Message::has_content() const {
  return content_case() != CONTENT_NOT_SET;
}
inline void Message::clear_has_content() {
  _impl_._oneof_case_[0] = CONTENT_NOT_SET;
}
inline Message::ContentCase Message::content_case() const {
  return Message::ContentCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace standard
}  // namespace chess

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::chess::standard::PieceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chess::standard::PieceType>() {
  return ::chess::standard::PieceType_descriptor();
}
template <> struct is_proto_enum< ::chess::standard::PieceColor> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chess::standard::PieceColor>() {
  return ::chess::standard::PieceColor_descriptor();
}
template <> struct is_proto_enum< ::chess::standard::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chess::standard::MessageType>() {
  return ::chess::standard::MessageType_descriptor();
}
template <> struct is_proto_enum< ::chess::standard::GameEndReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::chess::standard::GameEndReason>() {
  return ::chess::standard::GameEndReason_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_chess_2eproto
