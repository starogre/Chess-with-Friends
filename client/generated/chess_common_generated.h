// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CHESSCOMMON_CHESS_COMMON_H_
#define FLATBUFFERS_GENERATED_CHESSCOMMON_CHESS_COMMON_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

namespace chess {
namespace common {

struct Position;

struct Piece;
struct PieceBuilder;

struct BoardState;
struct BoardStateBuilder;

enum PieceType : int8_t {
  PieceType_PAWN = 0,
  PieceType_ROOK = 1,
  PieceType_KNIGHT = 2,
  PieceType_BISHOP = 3,
  PieceType_QUEEN = 4,
  PieceType_KING = 5,
  PieceType_MIN = PieceType_PAWN,
  PieceType_MAX = PieceType_KING
};

inline const PieceType (&EnumValuesPieceType())[6] {
  static const PieceType values[] = {
    PieceType_PAWN,
    PieceType_ROOK,
    PieceType_KNIGHT,
    PieceType_BISHOP,
    PieceType_QUEEN,
    PieceType_KING
  };
  return values;
}

inline const char * const *EnumNamesPieceType() {
  static const char * const names[7] = {
    "PAWN",
    "ROOK",
    "KNIGHT",
    "BISHOP",
    "QUEEN",
    "KING",
    nullptr
  };
  return names;
}

inline const char *EnumNamePieceType(PieceType e) {
  if (::flatbuffers::IsOutRange(e, PieceType_PAWN, PieceType_KING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPieceType()[index];
}

enum PieceColor : int8_t {
  PieceColor_WHITE = 0,
  PieceColor_BLACK = 1,
  PieceColor_MIN = PieceColor_WHITE,
  PieceColor_MAX = PieceColor_BLACK
};

inline const PieceColor (&EnumValuesPieceColor())[2] {
  static const PieceColor values[] = {
    PieceColor_WHITE,
    PieceColor_BLACK
  };
  return values;
}

inline const char * const *EnumNamesPieceColor() {
  static const char * const names[3] = {
    "WHITE",
    "BLACK",
    nullptr
  };
  return names;
}

inline const char *EnumNamePieceColor(PieceColor e) {
  if (::flatbuffers::IsOutRange(e, PieceColor_WHITE, PieceColor_BLACK)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPieceColor()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Position FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t x_;
  int8_t y_;

 public:
  Position()
      : x_(0),
        y_(0) {
  }
  Position(int8_t _x, int8_t _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  int8_t x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  int8_t y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Position, 2);

struct Piece FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PieceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PIECE_TYPE = 6,
    VT_COLOR = 8,
    VT_POSITION = 10
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  chess::common::PieceType piece_type() const {
    return static_cast<chess::common::PieceType>(GetField<int8_t>(VT_PIECE_TYPE, 0));
  }
  chess::common::PieceColor color() const {
    return static_cast<chess::common::PieceColor>(GetField<int8_t>(VT_COLOR, 0));
  }
  const chess::common::Position *position() const {
    return GetStruct<const chess::common::Position *>(VT_POSITION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyField<int8_t>(verifier, VT_PIECE_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_COLOR, 1) &&
           VerifyField<chess::common::Position>(verifier, VT_POSITION, 1) &&
           verifier.EndTable();
  }
};

struct PieceBuilder {
  typedef Piece Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Piece::VT_ID, id, 0);
  }
  void add_piece_type(chess::common::PieceType piece_type) {
    fbb_.AddElement<int8_t>(Piece::VT_PIECE_TYPE, static_cast<int8_t>(piece_type), 0);
  }
  void add_color(chess::common::PieceColor color) {
    fbb_.AddElement<int8_t>(Piece::VT_COLOR, static_cast<int8_t>(color), 0);
  }
  void add_position(const chess::common::Position *position) {
    fbb_.AddStruct(Piece::VT_POSITION, position);
  }
  explicit PieceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Piece> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Piece>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Piece> CreatePiece(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    chess::common::PieceType piece_type = chess::common::PieceType_PAWN,
    chess::common::PieceColor color = chess::common::PieceColor_WHITE,
    const chess::common::Position *position = nullptr) {
  PieceBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_id(id);
  builder_.add_color(color);
  builder_.add_piece_type(piece_type);
  return builder_.Finish();
}

struct BoardState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoardStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PIECES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<chess::common::Piece>> *pieces() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<chess::common::Piece>> *>(VT_PIECES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PIECES) &&
           verifier.VerifyVector(pieces()) &&
           verifier.VerifyVectorOfTables(pieces()) &&
           verifier.EndTable();
  }
};

struct BoardStateBuilder {
  typedef BoardState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pieces(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<chess::common::Piece>>> pieces) {
    fbb_.AddOffset(BoardState::VT_PIECES, pieces);
  }
  explicit BoardStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoardState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoardState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BoardState> CreateBoardState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<chess::common::Piece>>> pieces = 0) {
  BoardStateBuilder builder_(_fbb);
  builder_.add_pieces(pieces);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BoardState> CreateBoardStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<chess::common::Piece>> *pieces = nullptr) {
  auto pieces__ = pieces ? _fbb.CreateVector<::flatbuffers::Offset<chess::common::Piece>>(*pieces) : 0;
  return chess::common::CreateBoardState(
      _fbb,
      pieces__);
}

}  // namespace common
}  // namespace chess

#endif  // FLATBUFFERS_GENERATED_CHESSCOMMON_CHESS_COMMON_H_
